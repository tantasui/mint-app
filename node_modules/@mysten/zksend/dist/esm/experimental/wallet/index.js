var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _id, _events, _accounts, _origin, _walletName, _icon, _name, _signTransactionBlock, _signTransaction, _signAndExecuteTransaction, _signPersonalMessage, _on, _StashedWallet_instances, setAccounts_fn, _connect, _disconnect, getNewPopupChannel_fn;
import { Transaction } from "@mysten/sui/transactions";
import { fromBase64, toBase64 } from "@mysten/sui/utils";
import { getWallets, ReadonlyWalletAccount, SUI_CHAINS } from "@mysten/wallet-standard";
import mitt from "mitt";
import { boolean, object, parse, string } from "valibot";
import { DappPostMessageChannel, decodeJwtSession } from "@mysten/window-wallet-core";
const DEFAULT_STASHED_ORIGIN = "https://getstashed.com";
const STASHED_SESSION_KEY = "stashed:session";
const STASHED_WALLET_NAME = "Stashed";
const SUI_WALLET_EXTENSION_ID = "com.mystenlabs.suiwallet";
const METADATA_API_URL = "http://localhost:3001/api/wallet/metadata";
const WalletMetadataSchema = object({
  id: string("Wallet ID is required"),
  walletName: string("Wallet name is required"),
  icon: string("Icon must be a valid wallet icon format"),
  enabled: boolean("Enabled is required")
});
function setSessionToStorage(session) {
  localStorage.setItem(STASHED_SESSION_KEY, session);
}
function getSessionFromStorage() {
  const session = localStorage.getItem(STASHED_SESSION_KEY);
  if (!session) {
    throw new Error("No session found");
  }
  return session;
}
const walletAccountFeatures = [
  "sui:signTransaction",
  "sui:signAndExecuteTransaction",
  "sui:signPersonalMessage",
  "sui:signTransactionBlock",
  "sui:signAndExecuteTransactionBlock"
];
async function getAccountsFromSession(session) {
  const { payload } = await decodeJwtSession(session);
  return payload.accounts.map((account) => {
    return new ReadonlyWalletAccount({
      address: account.address,
      chains: SUI_CHAINS,
      features: walletAccountFeatures,
      publicKey: fromBase64(account.publicKey)
    });
  });
}
class StashedWallet {
  constructor({
    name,
    origin,
    metadata
  }) {
    __privateAdd(this, _StashedWallet_instances);
    __privateAdd(this, _id);
    __privateAdd(this, _events);
    __privateAdd(this, _accounts);
    __privateAdd(this, _origin);
    __privateAdd(this, _walletName);
    __privateAdd(this, _icon);
    __privateAdd(this, _name);
    __privateAdd(this, _signTransactionBlock, async ({
      transactionBlock,
      account,
      chain
    }) => {
      transactionBlock.setSenderIfNotSet(account.address);
      const data = await transactionBlock.toJSON();
      const popup = __privateMethod(this, _StashedWallet_instances, getNewPopupChannel_fn).call(this);
      const response = await popup.send({
        type: "sign-transaction",
        transaction: data,
        address: account.address,
        chain,
        session: getSessionFromStorage()
      });
      return {
        transactionBlockBytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _signTransaction, async ({ transaction, account, chain }) => {
      const popup = __privateMethod(this, _StashedWallet_instances, getNewPopupChannel_fn).call(this);
      const tx = await transaction.toJSON();
      const response = await popup.send({
        type: "sign-transaction",
        transaction: tx,
        address: account.address,
        chain,
        session: getSessionFromStorage()
      });
      return {
        bytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _signAndExecuteTransaction, async ({
      transaction,
      account,
      chain
    }) => {
      const popup = __privateMethod(this, _StashedWallet_instances, getNewPopupChannel_fn).call(this);
      const tx = Transaction.from(await transaction.toJSON());
      tx.setSenderIfNotSet(account.address);
      const data = await tx.toJSON();
      const response = await popup.send({
        type: "sign-and-execute-transaction",
        transaction: data,
        address: account.address,
        chain,
        session: getSessionFromStorage()
      });
      return {
        bytes: response.bytes,
        signature: response.signature,
        digest: response.digest,
        effects: response.effects
      };
    });
    __privateAdd(this, _signPersonalMessage, async ({ message, account }) => {
      const popup = __privateMethod(this, _StashedWallet_instances, getNewPopupChannel_fn).call(this);
      const response = await popup.send({
        type: "sign-personal-message",
        message: toBase64(message),
        address: account.address,
        session: getSessionFromStorage(),
        chain: account.chains[0]
      });
      return {
        bytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _on, (event, listener) => {
      __privateGet(this, _events).on(event, listener);
      return () => __privateGet(this, _events).off(event, listener);
    });
    __privateAdd(this, _connect, async (input) => {
      if (input?.silent) {
        try {
          const accounts = await getAccountsFromSession(getSessionFromStorage());
          if (accounts.length) {
            __privateMethod(this, _StashedWallet_instances, setAccounts_fn).call(this, accounts);
          }
        } catch (error) {
        }
        return { accounts: this.accounts };
      }
      const popup = __privateMethod(this, _StashedWallet_instances, getNewPopupChannel_fn).call(this);
      const response = await popup.send({
        type: "connect"
      });
      setSessionToStorage(response.session);
      __privateMethod(this, _StashedWallet_instances, setAccounts_fn).call(this, await getAccountsFromSession(response.session));
      return { accounts: this.accounts };
    });
    __privateAdd(this, _disconnect, async () => {
      localStorage.removeItem(STASHED_SESSION_KEY);
      __privateMethod(this, _StashedWallet_instances, setAccounts_fn).call(this, []);
    });
    __privateSet(this, _id, metadata.id);
    __privateSet(this, _accounts, []);
    __privateSet(this, _events, mitt());
    __privateSet(this, _origin, origin || DEFAULT_STASHED_ORIGIN);
    __privateSet(this, _name, name);
    __privateSet(this, _walletName, metadata.walletName);
    __privateSet(this, _icon, metadata.icon);
  }
  get name() {
    return __privateGet(this, _walletName);
  }
  get id() {
    return __privateGet(this, _id);
  }
  get icon() {
    return __privateGet(this, _icon);
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return SUI_CHAINS;
  }
  get accounts() {
    return __privateGet(this, _accounts);
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: __privateGet(this, _connect)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: __privateGet(this, _disconnect)
      },
      "standard:events": {
        version: "1.0.0",
        on: __privateGet(this, _on)
      },
      "sui:signTransactionBlock": {
        version: "1.0.0",
        signTransactionBlock: __privateGet(this, _signTransactionBlock)
      },
      "sui:signTransaction": {
        version: "2.0.0",
        signTransaction: __privateGet(this, _signTransaction)
      },
      "sui:signPersonalMessage": {
        version: "1.1.0",
        signPersonalMessage: __privateGet(this, _signPersonalMessage)
      },
      "sui:signAndExecuteTransaction": {
        version: "2.0.0",
        signAndExecuteTransaction: __privateGet(this, _signAndExecuteTransaction)
      }
    };
  }
}
_id = new WeakMap();
_events = new WeakMap();
_accounts = new WeakMap();
_origin = new WeakMap();
_walletName = new WeakMap();
_icon = new WeakMap();
_name = new WeakMap();
_signTransactionBlock = new WeakMap();
_signTransaction = new WeakMap();
_signAndExecuteTransaction = new WeakMap();
_signPersonalMessage = new WeakMap();
_on = new WeakMap();
_StashedWallet_instances = new WeakSet();
setAccounts_fn = function(accounts) {
  __privateSet(this, _accounts, accounts);
  __privateGet(this, _events).emit("change", { accounts: this.accounts });
};
_connect = new WeakMap();
_disconnect = new WeakMap();
getNewPopupChannel_fn = function() {
  return new DappPostMessageChannel({
    appName: __privateGet(this, _name),
    hostOrigin: __privateGet(this, _origin)
  });
};
async function fetchMetadata(metadataApiUrl) {
  const response = await fetch(metadataApiUrl);
  if (!response.ok) {
    throw new Error("Failed to fetch wallet metadata");
  }
  const data = await response.json();
  return parse(WalletMetadataSchema, data);
}
async function registerStashedWallet(name, {
  origin,
  metadataApiUrl = METADATA_API_URL
} = {}) {
  const wallets = getWallets();
  const extension = wallets.get().find((wallet) => wallet.id === SUI_WALLET_EXTENSION_ID);
  if (extension) {
    return;
  }
  let metadata;
  try {
    metadata = await fetchMetadata(metadataApiUrl);
  } catch (error) {
    console.error("Error fetching metadata", error);
  }
  if (!metadata?.enabled) {
    console.log("Stashed wallet is not currently enabled.");
    return;
  }
  const stashedWalletInstance = new StashedWallet({
    name,
    origin,
    metadata
  });
  const unregister = wallets.register(stashedWalletInstance);
  wallets.on("register", (wallet) => {
    if (wallet.id === SUI_WALLET_EXTENSION_ID) {
      unregister();
    }
  });
  return {
    wallet: stashedWalletInstance,
    unregister
  };
}
export {
  STASHED_WALLET_NAME,
  StashedWallet,
  registerStashedWallet
};
//# sourceMappingURL=index.js.map
